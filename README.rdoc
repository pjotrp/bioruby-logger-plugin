= bio-logger

This is a plugin for sane handling of errors and exceptions in different
situations (log-act):

* Normal user
* Developer
* Web server
* Fault-tolerant systems

One example of having different behaviours is when a program logs a warning to
stdout as a user, but raises an exception as a developer.

bio-logger builds up on log4r functionality, which comes with multiple
handlers, such as a rotating and remote logging, and is thread-safe. Next to
adding behaviours, bio-logger introduces a more fine-grained approach for
logging errors. I.e. within 'debug', 'info', 'warn', 'error' and 'fatal', an
additional value 1..9 can be set to limit output and logging.

bio-logger can also parse for command line switches:

  --logger stderr              Add stderr logger
  --logger filen               Add filename logger
  --trace  debug               Show all messages 
  --trace  warn                Show messages more serious than 'warn'
  --trace  warn:3              Show messaged more serious that 'warn' level 3

overrides:

  --trace  gff3:info:5         Override level for 'gff3' to info level 5
  --trace  blast:debug         Override level for 'blast'
  --trace  blast,gff3:debug    Override level for 'blast' and 'gff3' 
  --trace  stderr:blast:debug  Override level for 'blast' on stderr 

Behaviour, or 'acting', can be changed. This normally happens through library
calls. There is one command line switch, which changes log-act:

  --log-act Developer          Modify the logger for development

which will cause, for example, 'error' and 'fatal' to fail during development.
New behaviour can be implemented by deriving from an existing class.

== Install bio-logger

  gem install bio-logger

== Bio::Log API

  require 'bio-logger'
  include Bio::Log

  # ==== Create loggers
  log = LoggerPlus.new 'mylog'
  log.outputters = Outputter.stderr

  # create a second rotating log for BLAST
  config = {
    "filename" => "log/blast.log",  # make sure the dir exists!
    "maxsize" => 16000,             # max file size
    "trunc" => false                # don't delete log
  }
  log2 = LoggerPlus.new 'blast'
  log2.outputters = RollingFileOutputter.new("blast", config)

  # ==== Output messages on 'mylog'
  log.debug "This is a message with level DEBUG"
  log.info "This is a message with level INFO"
  log.warn "This is a message with level WARN"
  log.error "This is a message with level ERROR"
  log.fatal "This is a message with level FATAL"
  log.warn3 "This is a message with level WARN:3"

  # Restrict output to WARN:3
  log.level = WARN
  log.sub_level = 3
  log.info("This is a message with level INFO")      # not logged
  log.warn8("This is a message with level WARN:8")   # not logged
  log.warn1("This is a message with level WARN:1")   # logged
  log.warn("This is a message with level WARN")      # logged

  # Fetch the BLAST logger (assuming it exists)
  blastlog = LoggerPlus['blast']
  blastlog.warn("This is a message with level WARN") # logged

  # Special logging behaviour, based on actual user
  blastlog.error_("ERROR should not fail",:act => NormalUser.new)
  dev = Developer.new
  blastlog.info_("INFO should not fail",:act => dev)
  blastlog.error_("As Developer ERROR should fail",:act => dev)

== Documentation

The log4r documentation and source code can be used, as this Logger 
implementation passes everything down, except for the added methods.

See the Specs in ./spec for more examples. Run the Specs with

  rspec spec/*.rb

== Copyright

Copyright (C) 2011 Pjotr Prins <pjotr.prins@thebird.nl> 

See LICENSE.txt for further details.

